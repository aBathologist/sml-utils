(*

* PetiTest A tiny testing utility

A tiny testing utility for sml.
Likely the most petite.

** Usage:

*** Define a few tests:

#+BEGIN_SRC sml
val test1 = Test.isTrue "test name" condition
val test2 = Test.isTrue "other name" otherCondition
#+END_SRC

*** Define a suite of tests:

#+BEGIN_SRC sml
      structure Test = PetiTest
val testSuite = Test.suite
    [
      Test.isTrue "name"
                  condition,
      Test.isTrue "name'"
                  condition',
      ...
      Test.isTrue "2 greater than 5"
                  (2 > 5),
    ]
#+END_SRC

*** Run a report on a siute

#+BEGIN_SRC sml
Test.run testSuite;
#+END_SRC

Or you can just call ~Test.run~ on the list of tests directly.

*** The output generated by running a suite

Given a test suite

#+BEGIN_SRC sml
fun test_test_suite () =

    Test.run
        [ Test.isTrue "passes"
                 true,

          Test.isTrue "conditional pass"
                 (2 = 2),

          Test.isTrue "complex pass"
                 ( let val x = 2
                       val y = 2
                   in
                       x = y
                   end ),


          Test.isTrue "failing test" false,
          Test.isTrue "other failing test" false,

          Test.isTrue "the property is tested"
                 ( 4 > 2 )
        ]
#+END_SRC

The output of ~Test.run test_test_suite~ will be

#+BEGIN_QUOTE
------

6 tests run in total.
2 tests failed:

  Test "failing test": FAILED
  Test "other failing test": FAILED

------
#+END_QUOTE

And for a fully passing suite:

#+BEGIN_QUOTE
------

6 tests run in total.
All tests passed.

------
#+END_QUOTE

** Looking forward

The PetiTest module is intended for simplistic pragmatic purposes.

The ML module system is descended from OBJ specification modules. A proper test
framework for an ML language should, it seems obvious to say, integrate tightly
with a module's signature; for the signature is a partial formal specification
of the module. The tests are only needed to fill in the gaps where the type
system cannot provide securities.

This is probably already well covered territory.

*)

signature PETI_TEST =
sig

    type name
    datatype result = PASSED | FAILED
    datatype test = TEST of name * result
    type suite_results = { num_tests    : int,
                           num_failed   : int,
                           failed_tests : test list }

    val isTrue : string -> bool -> test
    val suite  : test list -> suite_results

    (* TODO: Get rid of this function & put pretty printing in the compiler *)
    val run : test list -> unit

    val testToString  : test -> string
    val suiteToString : suite_results -> string


end (* PETI_TEST *)

structure PetiTest : PETI_TEST =
struct

    structure L = ListPlus

    type name = string

    datatype result = PASSED | FAILED

    datatype test = TEST of name * result
    type suite_results = { num_tests    : int,
                           num_failed   : int,
                           failed_tests : test list }

    fun isTrue name condition =
      TEST (name, if condition then PASSED else FAILED)

    fun suite tests =
      let
          fun testPassed (TEST (_, PASSED)) = true
           |  testPassed (TEST (_, FAILED)) = false
          val failed_tests = L.filter (not o testPassed) tests
      in
          { num_tests    = L.length tests,
            num_failed   = L.length failed_tests,
            failed_tests = failed_tests }
      end


    fun testToString (TEST (name, result)) =
      "Test \"" ^ name ^ "\": "  ^ ( case result
                                      of PASSED => "PASSED"
                                      |  FAILED => "FAILED" )

    fun suiteToString {num_tests, num_failed, failed_tests} =
      let
          fun indentTest t = "  " ^ (testToString t) ^ "\n"
          val testPl = if num_failed = 1 then "test" else "tests"
          val numFailedStr = (Int.toString num_failed)
          val report = if   num_failed = 0
                       then "All tests passed.\n"
                       else  numFailedStr ^ " " ^ testPl ^ " failed:\n\n" ^
                             (String.concat o L.map indentTest) failed_tests
      in
          "\n------\n\n" ^
          Int.toString num_tests ^ " tests run in total.\n" ^
          report ^
          "\n------\n\n"
      end

    fun run tests = (print o suiteToString o suite) tests

    (* Eventually, the results should just be pretty printed via the values reporeted by the comipler. *)
    (* For now, however, I must rely on a side effect. *)
    (* fun ppTest ppstream t = PrettyPrint.string ppstream (testToString t) *)
    (* fun ppSuite ppstream s = PrettyPrint.string ppstream (suiteToString s) *)

end (* PetiTest *)
