(*

* PetiTest A tiny testing utility

A tiny testing utility for sml.
Likely the most petite.

** Usage:

*** Define a few tests:

#+BEGIN_SRC sml
local open PetiTest in
  val test1 = test "test name" condition
  val test2 = test "other name" otherCondition
end
#+END_SRC

*** Define a suite of tests:

#+BEGIN_SRC sml
structure Test = PetiTest
val testSuite = Test.suite
    [
      test "name"
            condition,
      test "name'"
           condition',
      ...
      test "2 greater than 5"
           (2 > 5)
    ]
#+END_SRC

*** Run a report on a siute

#+BEGIN_SRC sml
Test.run testSuite;
#+END_SRC

Or you can just call ~Test.run~ on the list of tests directly.

*** The output generated by running a suite

Given a test suite

#+BEGIN_SRC sml
fun test_test_suite () =

    Test.run
        [ test "passes"
               true,

          test "conditional pass"
               (2 = 2),

          test "complex pass"
               ( let val x = 2
                     val y = 2
                 in
                     x = y
                 end ),


          test "failing test" false,
          test "other failing test" false,

          test "the property is tested"
               ( 4 > 2 )
        ]
#+END_SRC

The output of ~Test.run test_test_suite~ will be

#+BEGIN_QUOTE
------

6 tests run in total.
2 tests failed:

  Test "failing test": FAILED
  Test "other failing test": FAILED

------
#+END_QUOTE

And for a fully passing suite:

#+BEGIN_QUOTE
------

6 tests run in total.
All tests passed.

------
#+END_QUOTE

** Looking forward

The PetiTest module is intended for simplistic pragmatic purposes.

The ML module system is descended from OBJ specification modules. A proper test
framework for an ML language should, it seems obvious to say, integrate tightly
with a module's signature; for the signature is a partial formal specification
of the module. The tests are only needed to fill in the gaps where the type
system cannot provide securities.

This is probably already well covered territory.

*)

signature PETI_TEST =
sig

    type name
    datatype result = PASSED | FAILED
    datatype test = TEST of name * result
    type suite_results = { name         : name,
                           num_tests    : int,
                           num_failed   : int,
                           failed_tests : test list }

    val test : string -> bool -> test
    val suite  : name -> test list -> suite_results

    (* TODO: Get rid of this function & put pretty printing in the compiler *)
    val run : suite_results -> unit

    val testToString  : test -> string
    val suiteToString : suite_results -> string


end (* PETI_TEST *)

structure PetiTest : PETI_TEST =
struct

    structure L = ListPlus

    type name = string

    datatype result = PASSED | FAILED

    datatype test = TEST of name * result
    type suite_results = { name         : name,
                           num_tests    : int,
                           num_failed   : int,
                           failed_tests : test list }

    fun test name condition =
      TEST (name, if condition then PASSED else FAILED)

    fun suite name tests =
      let
          fun testPassed (TEST (_, PASSED)) = true
           |  testPassed (TEST (_, FAILED)) = false
          val failed_tests = L.filter (not o testPassed) tests
      in
          { name         = name,
            num_tests    = L.length tests,
            num_failed   = L.length failed_tests,
            failed_tests = failed_tests }
      end


    fun testToString (TEST (name, result)) =
      "Test \"" ^ name ^ "\": "  ^ ( case result
                                      of PASSED => "PASSED"
                                      |  FAILED => "FAILED" )

    fun suiteToString {name, num_tests, num_failed, failed_tests} =
      let
          fun indentTest t = "  " ^ (testToString t) ^ "\n"
          val testPl = if num_failed = 1 then "test" else "tests"
          val numFailedStr = (Int.toString num_failed)
          val report = if   num_failed = 0
                       then "All tests passed.\n"
                       else  numFailedStr ^ " " ^ testPl ^ " failed:\n\n" ^
                             (String.concat o L.map indentTest) failed_tests
      in
          "\n------\n\n" ^
          "Test suite: " ^ name ^ "\n\n" ^
          Int.toString num_tests ^ " tests run in total.\n" ^
          report ^
          "\n------\n\n"
      end

    fun run testSuite = (print o suiteToString) testSuite

    (* Eventually, the results should just be pretty printed via the values
       reported by the compiler.
    For now, however, I must rely on a side effect.
    fun ppTest ppstream t = PrettyPrint.string ppstream (testToString t)
    fun ppSuite ppstream s = PrettyPrint.string ppstream (suiteToString s) *)

end (* PetiTest *)
